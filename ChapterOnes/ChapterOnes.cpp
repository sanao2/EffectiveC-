#include "pch.h"

/*----------------------------------------------항목 1------------------------------------------------------------------------------------*/

/*----------------------------------------------항목 2------------------------------------------------------------------------------------*/
#define SIZE 1000 
// 매크로 상수 정의 
// 매크로 상수는 컴파일러가 처리하는 전처리기 지시문
// 매크로는 컴파일이 끝날 때까지 유효! 
// 그러나, private 같은 성질의 매크로는 없기 때문에, 
// 이곳저곳에서 수정이 가능한 장점이자 단점이 있다. 

// < ---- 매크로 상수 ---- > 
/// <summary>
/// 컴파일러가 각 위치마다 상수로 처리. = 호출 위치마다 새로운 사본을 만들어 사용한다. 
/// 경우에 따라 중복된 코드 또는 상수 테이블 항목이 늘어날 수 있다. = 메모리 사용량 증가 
/// 즉, 중복된 상수 사본이 생기며, 메모리 절약이 안될 수 있다. 
/// (만약 복잡한 객체나 배열 등에서는 더 심각하게 메모리가 부족할 가능성이 높다.) 
/// 결국 나중에 가서는 const 로 변경 해야 한다. 
/// </summary>

// <--------------------------------------------------------------------------------------기호 테이블---------------------------------------------------->  
/// <summary>  
///  기호테이블이란?  
///  
///  1. 컴파일러가 소스 코드를 분석하고 처리하는 과정에서 사용되는 핵심 자료구조 중 하나.
///  2. 소스 코드에 등장하는 모든 식별자(변수명, 함수명, 클래스명 등)와 이들과 관련된 속성(자료형, 선언 위치, 메모리 주소 등)을 저장 / 관리하는 표와 비슷하다.
///  3. 이 변수는 상수인가? , 이 함수가 인라인될 수 있는가? 라는 부가적인 속성을 보관하기도 한다. 
/// 
///  즉, 식별자가 어디에서 선언되고 호출되는 지, 어디까지 유효한지, 이 식별자가 어떤 타입이고 어떤 속성을 갖고 있는지 등을 검색하고 조회해 컴파일러에서 분석할 수 있도록 관리한다. 
/// 
/// 기호 테이블의 목적. 
///  1. 식별자 관리. 
///    : 모든 식별자들의 정보를 모아두고, 각 식별자의 속성(타입 정보, 함수라면 반환값 정보 등)을 빠르게 조회할 수 있도록 한다. 
/// 
///		- 중복 선언 및 미선언 사용 검출 
///		  : 이미 같은 이름의 식별자가 존재하는 지 확인해서 중복된 선언 오류를 검출. -> 예시 오류 : 같은 변수가 여러번 정의되었습니다. 등. 
/// 
///		- 선언되지 않은 변수 또는 함수를 사용하려는 사용자에게 오류를 발생. 
///  
///  2. 스코프(식별자의 유효 범위) 관리 
///     - 전역 변수, 지역 변수, 블록 별 스코프 등의 서로 다른 범위 내에서 같은 식별자를 사용할 수 있도록 한다. 
///     - 스코프 단위로 기호 테이블을 관리 하거나, 단일 테이블 안에서 스코프 정보를 구분해 삽입 / 삭제 함으로서 어떤 선언이 현재 위치에서 유효한지, 를 판단한다. 
///     - 즉, {} 마다 사용범위가 유효한 변수, 함수 등의 유효 범위를 관리하고 판단한다. 
/// 
///  3. 코드 생성 및 최적화 지원 
///     - 컴파일러가 중간 코드 나 기계어를 생성할 때, 각 식별자의 메모리 주소 (스택 오프셋, 레지스터 번호 등) 나 자료형 정보를 참조 한다. 
///     - 기호 테이블 내에서 꺼낸 정보를 바탕으로, 코드 생성 시 필요한 참조 연산을 올바르게 수행 할 수 있도록 한다. 
/// 
/// </summary>

//----------------------------------------------------------------------------------------상수 키워드 const 를 define 대신 사용해봐라.
const int sized = 1000;
// const 키워드 사용 
// sized = 1000; // const 키워드는 상수로 선언된 변수의 값을 변경할 수 없도록 한다.
// 즉, sized 는 상수로 선언되어서, 값을 변경할 수 없다.

int sizeB = sized; // const  상수 사용 

// <---- const 상수 ---- > 
/// <summary>
///  const 로 선언된 sized 는 하나의 메모리 공간에만 지정되어서 저장된다.
///  sizeB 는 sized 의 메모리 주소를 참조나 값을 복사해서 사용 
///  결과적으로 중복된 상수 값이 줄어들고, 메모리 사용이 더 효율적이다. 
///  특히 큰 배열이나, 문자열이라면 이 차이가 엄청나게 커진다. 
/// </summary>

// const 키워드로 만든 상수를 사용시, 사본은 단 한번만 만들어지며 sizeB 가 가지는 메모리에 단한번 만들어졌던 사본 값이 들어간다. 
// 즉, 매크로 상수는 컴파일 타임에 치환되어 코드에 삽입되지만, const 상수는 변수처럼 동작한다

int sizeA = SIZE;  // 매크로 상수 사용 

// ---------------------------------------------------------------------------------------------매크로대신 const 사용 이유 
/// <summary>
/// 1. 개발자의 실수를 방지 
/// </summary>

void print(const string& name);

class Person {
public:
	string name() const;
	// 객체의 상태를 변경하지 않겠다 라는 의미다.
	// 읽기 전용. 
	// 멤버 함수 const 객체에서는 호출 가능.

};
class cClass {
public: // 테스트를 위한 임시로 public 선언. 원래는 private로 선언해야함. 

	// 클래스 상수는 선언된 시점에 바로 초기값을 할당해야 함. 
	static const int NumScore = 5; // 정적 클래스 상수 
	// 객체가 가진 딱 하나만 존재하게 만들고, 
	// 객체가 생성될 때마다 같은 메모리의 인스턴스를 공유해 사용하게 한다. 
	// 정적 멤버로 만들어서 상수의 값의 사본을 한개 이상으로 만들지 못하게 함. 
	// 즉, 모든 객체가 하나의 메모리를 공유하게 한다. 

	const int NumScoreTwo = 5;	   // 비정적 클래스 상수 
	// 이 경우, 객체가 생성될 때마다 메모리에 별도의 공간을 할당받는다. 
	// 즉, 객체마다 새로운 메모리를 할당 받는다. 

	int scores[NumScore];

public:
	cClass() : scores{ NULL } {} // 생성자에서 배열을 초기화한다.  // 추후 항목 4 에서 초기화와 대입의 차이점 정리 
	// 생성자에서 scores 배열을 초기화한다.

	void debug_print(const char* objName) const {
		std::cout << "---- [" << objName << "] 디버그 정보 ----\n";
		// 1) 이 객체가 가진 NumScoreTwo(비정적 상수)의 주소
		std::cout << "  &" << objName << ".NumScoreTwo = "
			<< static_cast<const void*>(&NumScoreTwo)
			<< "  (값: " << NumScoreTwo << ")\n";

		// 2) 이 객체가 가진 scores 배열(크기 5) 첫 원소의 주소
		std::cout << "  &" << objName << ".scores[0] = "
			<< static_cast<const void*>(&scores[0])
			<< "\n";

		// 3) 이 객체의 this 포인터 주소 (즉, 객체의 시작 주소)
		std::cout << "  this (" << objName << ") 주소 = "
			<< static_cast<const void*>(this)
			<< "\n";
		std::cout << "---------------------------------\n\n";
	}
};

void cClassTest() {
	// 두 개의 cClass 객체를 생성
	cClass objA;
	cClass objB;

	// 정적 멤버 상수 NumScore의 주소(모든 객체가 공유)
	//    - 클래스 이름을 통해 접근 가능: &cClass::NumScore
	//    - 또는, objA.NumScore, objB.NumScore 로도 동일하게 출력됨
	std::cout << "=== 정적(static) 멤버 상수 NumScore 주소 확인 ===\n";
	std::cout << " &cClass::NumScore = "
		<< static_cast<const void*>(&cClass::NumScore)
		<< "  (값: " << cClass::NumScore << endl;
	std::cout << " objA.NumScore      = "
		<< static_cast<const void*>(&objA.NumScore)
		<< endl;
	std::cout << " objB.NumScore      = "
		<< static_cast<const void*>(&objB.NumScore)
		<< endl;
	std::cout << "(위 세 줄이 모두 동일한 주소를 가리킴)\n\n";

	// 비정적 멤버 상수 NumScoreTwo 주소 확인
	std::cout << "=== 비정적 멤버 상수 NumScoreTwo 주소 확인 ===\n";
	std::cout << " &objA.NumScoreTwo = "
		<< static_cast<const void*>(&objA.NumScoreTwo)
		<< "  (값: " << objA.NumScoreTwo << endl;
	std::cout << " &objB.NumScoreTwo = "
		<< static_cast<const void*>(&objB.NumScoreTwo)
		<< endl;
	std::cout << "(objA와 objB의 NumScoreTwo는 서로 다른 주소를 가짐)\n\n";

	// objA와 objB의 멤버 디버그 프린트
	objA.debug_print("objA");
	objB.debug_print("objB");
}
// private 멤버 변수는 클래스 내부에서만 접근 가능하다. 

// 나열자 둔갑술 

// 나열자 둔갑술을 사용하는 이유 
/// <summary>
///  1. 기호식 이름을 사용하지 않는 define을 대신해서 사용.
///  2. define 에 가까운 동작 방식 
///  3. define 과 동일하게 주소를 가져오는 것은 불가능! (즉, 사용자가 나열자의 주소를 얻지 못하도록 하기 위함) 
///  4. 정적 클래스 멤버가 선언된 시점에 초기값을 주는 것이 맞지 않다고 판단하는 오래된 컴파일러들을 대응하기 위함. 
///  5. 오래된 컴파일러들이 선언된 시점에 초기값을 주는 것이 맞지 않다고 판단하는 이유에는 클래스 내부 초기화를 허용하는 경우가 정수 타입의 상수에 대해서만 국한되어있기 때문도 있다. 
///
/// 하지만, 
/// 
///  예외의 상황. 
///  > 해당 클래스를 컴파일 하는 도중, 클래스 상수의 값이 필요할 떄. 
///  > 정적 정수 클래스 상수에 대한 클래스 내 초기화를 금지하는 구식 컴파일러에 대한 배려를 위해 나열자 둔갑술을 사용.
/// 
/// 즉, 오래된 컴파일러에서 선언과 동시에 초기값을 주는 행동이 맞지 않다는 판단을 해결하기 위해서, define 과 동작 방식이 가까운 나열자 둔갑술을 사용하는 법도 가능하다. 
/// </summary>

class Game {
private:
	enum { NUMSCORE = 5 }; // 5에 대한 기호식 이름으로 변환 

	int EnumScore[NUMSCORE]; // 배열 선언 

	/// <summary>
	/// 나열자 둔값술의 원리. 
	/// 나열자(enumerator) 타입의 값은 int가 놓일 곳에도 사용할 수 있다. 라는 c++ 의 진실을 적극 활용하기. 
	/// </summary>

	/// <summary>
	/// 나열자 둔갑술의 좋은 점.
	/// 1. 동작 방식이 const 보다 #define 에 가깝다. 
	///   - 주소값을 얻지 못함 : const의 주소를 얻는 것은 가능 하지만, define의 주소를 얻는 것은 불가능하다. 
	///   - 정수 상수를 갖고 다른 사람이 주소를 얻지 못하게 하고, 참조자를 사용할 수 없도록 하는 것이 목적이라면 나열자 둔갑술을 사용하는 것이 좋은 방법
	/// 
	/// 2. 정수 타입의 const 객체에 대해서 저장공간을 준비하지 않겠지만, 조금 좋지 않게 만들어진 컴파일러는 반대로 동작. 
	///	   (정수 타입의 const 객체에 대한 메모리를 따로 준비하지 않는다. 그러나 하위 컴파일러들은 그 반대로 적용할 수 있음.) 
	///   - 안전하게 const 객체에 대한 메모리를 만들지 않는 방법이 된다. 
	///   - define 처럼 쓸데없는 메모리 할당을 하지 않는다.
	///   - 즉, 중복된 상수를 만들지 않는다. 
	/// 
	/// 3. 나열자 둔갑술에 익숙해져라. 
	///   - 많이 쓰이고있는 기법인 만큼, 쉽게 알아볼 수 있도록 단련이 필요하다.  
	/// 
	/// 
	/// 즉, define 에 가까운 동작을 하는 정수 타입의 상수 객체에 대한 중복된 상수를 만들지 않는 기법이 나열자둔갑술이다. 
	/// </summary>
public:

	/// <summary>
	/// define 오용 사례 
	/// 1. 매크로 함수. 
	///   - 함수처럼 보이지만 함수 호출 오버헤드를 일으키지 않는 매크로를 구현하는 것. 
	///   - 매크로 작성 시 본문에 있는 인자마다 반드시 괄호를 씌워줄 것. 
	///   - 표현식을 매크로로 넘길 때 매크로 비교 연산에 의한 처리한 결과가 어떤 것이냐에 따라 달라질 위험 있음.

	/// 즉, 함수처럼 보이는 매크로를 구현할 시, 표현식을 매크로에 넘길 때 비교 연산에 따라서 처리한 결과가 달라질 수 있기 때문에, 괄호의 사용이 중요하다.
	/// </summary>

	/// <summary>
	///  인라인 함수에 대한 템플릿! 
	///  - 기존 매크로의 효율을 그대로 유지하며, 정규 함수의 모든 동작방식 및 타입 안정성까지 높이는 방법 
	///  - 동일 계열 함수군을 만들어, 동일한 타입의 객체 두개를 인자로 받아 둘 중 큰 것을 f에 넘겨서 호출하는 구조.  
	///  - 인자를 여러번 평가할지도 모른다는 예외를 신경쓰지 않아도 되게 된다. 
	/// 동일 계열 함수군 이란? 
	///   1. 하나의 템플릿으로 부터 생성 되는 여러 함수들의 집합! 
	///   2. 템플릿 타입 T를 받아서, 서로 다른 타입의 매개변수에 대한 각각의 별도의 함수 정의를 생성하는 것. 
	///   3. 즉, 하나의 템플릿 선언으로부터, '여러개의 서로 다른 타입에 대응하는 함수 정의가 만들어지는 것' 을 말한다. 
	///    - 템플릿 타입 T로 선언된 타입은 int, float , char 등의 다양한 서로 다른 타입이 정의될 수 있다. 
	/// 왜 동일 계열 이라고 부르는 지? 
	///   1. 템플릿 선언 자체는 알고리즘(또는 로직)만을 기술. 
	///   2. 실제 함수는 컴파일 시, 'T 대신 실제 타입' 을 대입하면서 복사 / 생성 하기 때문. 
	///   3. T 가 int 타입일 때와, double 타입일 때 각각의 생성된 함수는 '함수 이름은 같지만 타입만 다른 서로 같은 계열'에 속하는 함수들을 말함. 
	///   4. 함수 시그니처만 달라질 뿐, 구현 내용은 동일하기 때문에, 관점에 따라서는 '동일한 로직을 수행하지만 타입만 다른 여러 함수'.
	/// 
	/// <즉, 템플릿으로 받는 typename 으로 선언된 T가 사용이 될 때 받는 실제 타입을 복사 / 생성 하면서, 같은 함수 이름이지만 다른 타입을 사용할 수 있다. >
	/// 
	/// 인라인 함수와의 관계란? 
	///   1. 템플릿으로 정의된 인라인 함수가 여러 타입으로 인스턴스화 되면, 각각의 인스턴스화 된 인라인 함수는 인라인이 가능한 동일 계열 함수가 된다. 
	///   2. 하나의 템플릿 선언 -> 여러 인라인 함수 인스턴스(동일 계열 함수군) 이란 구조를 가진다. 

	template <typename T>
	inline T CallWidthMin(const T& a, const T& b) // 어떤 타입으로 적용할 지 헷갈릴 가능성이 있지 않을까? 
	{
		cout << "T& a 값 : " << a << endl << "T& b 값 : " << b << endl;
		cout << "a 자료형 : " << typeid(a).name() << endl;
		cout << "b 자료형 : " << typeid(b).name() << endl;
		// 함수를 호출 시, 파라메터에도 문제 없이 전달 가능. 
		// 다만, 타입 간의 연산은 주의할 필요 있음. 
		// T 로 전달받은 파라메터 T의 타입은 int 형인데, 함수가 float 파라메터를 받는다면, 
		// 결과 값은 정수 처럼 나오지만, 사실상 실수 의 값이 정수처럼 잘려서 나올 수도 있음.  
		return sum(a, b);

	}

	float sum(float a, float b) {
		cout << "float a 값 : " << a << endl << "float b 값 : " << b << endl;
		cout << "a 자료형 : " << typeid(a).name() << endl;
		cout << "b 자료형 : " << typeid(b).name() << endl;
		cout << "float a + float b = " << a + b << endl;
		return a + b;
	}
	/// </summary>
};


/*----------------------------------------------항목 3------------------------------------------------------------------------------------*/
#include <string>
#include <vector>

// c++ 에서는 const 의 의미적인 제약을 소스 코드 수준에서 붙인다는 점. 
// 그리고, 컴파일러가 이 제약을 단단히 지켜준다. 

// 변경할 가능성이 있기 때문에 컴파일러에서 컴파일이 들어갈 가능성이 있다. 
const int* PointerConstValue = nullptr; // 상수 값 
int* const PointerConstType = nullptr;  // 포인터 상수 
const int* const PointerConstandConstVaue = nullptr; // 상수 포인터 > 값도, 가리키는 포인터도 절대 변경 사항이 없기 때문에 컴파일러가 한번 컴파일 한 이후로는 절대 하지 않는다. 성능 차이가 대단하다.

class P {
private:
	//std::string name() const;
	// 객체 상태를 변경하지 않겠다.
	// 멤버 함수 const 객체에서는 호출이 가능.
	std::string name;
public:
	P(const string& n) : name(n) {}

	static const int sum(int a, int b) { return a + b; }
	// 클래스 내부에서는 정적 / 비정적 인 멤버 함수 / 멤버 변수 모두 상수로 선언 가능. 

	string getName() const { return name; }			  // const 멤버 함수
	void SetName(const std::string& n) { name = n; }  // const 멤버 함수는 호출 불가
	// 지역객체 또는 파라메터를 수정할 수 없게 하고 싶다면, const 를 잊지 말라. 
	// 사용자의 실수를 줄여줄 수 있음. 
};

class OOPConst {
public:
	const char& operator[](int index) const 
	{
		return text[index];
	}
	char& operator[] (int index)
	{
		return text[index];

	}

	OOPConst(const std::string& str) : text(str) {} // 생성자에서 문자열 초기화 
private:
	string text;

};

void ConstOOPTest() {
	OOPConst opc("Kurenai");
	cout << opc[0] << endl; // 비상수 멤버 함수 호출 
	cout << endl;

	const OOPConst opclass("Aizawa");
	cout << opclass[0] << endl;


}

void ConstClassFuction() {
	// const P p; // const 객체
	//p.name(); // const 객체에서 호출 가능 but, 읽어오기만 가능

	P p("A");

	std::cout << p.getName() << std::endl; // const 멤버 함수 호출 가능
}

const int constClassFunction(int a, const int& b)
{
	a += b; // a는 const 선언이 되어있지 않는 값이고, 복사되는 값이기 때문에 가능!  
	//b -= a; // b는 const 선언이 된 참조자 이기 때문에 원본값을 변경 불가능! 

	return a;
}

// 수정된 함수 선언 및 정의
const int constclassFunctionSum(int a, int b) {

	return a + b;  // 반환될 때 , 값이 달라지지 않는 const int 타입을 가진다. 
	// 다만, int x 와 같은 일반 변수에 대입 시, 
	// 일반 자료형 형태로 담긴다. 

}


/// <summary>
/// const 멤버 함수 의 목적과 역할 
///  1. 해당 멤버 함수가 상수 객체에 대하여 호출될 함수라는 것을 알려주는 것. 
///  2. 클래스에서 객체를 변경할 수있는 함수는 무엇이고, 또 변경할 수 없는 함수는 무엇인지를 사용자 측에서 알고 있어야 하는 것들이다. 
///  3. 상수 객체를 사용할 수 있게 하는 것. 

/// C++ 프로그램의 실행 성능을 높이는 핵심 기법 중 하나가, 객체 전달을 '상수 객체에 대한 참조자'로 진행하는 것. -> const int& a 와 같은 파라메터들? 
///  즉, 상수 상태로 전달된 객체를 조작할 수 있는 상수 멤버 함수가 준비되어 있어야 한다. 

/// const int Function(); - 반환값 상수  
/// int const ff();		  - const int 와 같은 의미. 
///  - 위 두가지는 int 값을 복사해서 돌려주되, 그 복사된 값을 읽기 전용으로 취급. 
/// int Function() const; - 상수 멤버 함수

/// const 키워드 존재 여부에 따른 오버로딩 
///  1.실제 프로그램 내에서 상수객체가 생기는 경우는? 
///    - 상수 객체에 대한 포인터  
///    - 상수 객체에 대한 참조자로 객체가 전달될 때 
/// 
///  반환 타입에 대한 상수 멤버 함수인지, 아니면 멤버 함수 자체가 상수인지에 따라 호출되는 함수가 달라짐. 
/// </summary>

/// <summary>
///  비상수 멤버 참조자 반환 
///     예시 > char& operator[] (int pos); 

///  일반 자료형 char로 반환 시 오버로드 되는 오퍼레이터에서는 값의 대입(할당)이 불가능해진다. 
///     예시 > char operator[] (int pos); -> 호출부 - ch[0] = 'X'; 가 불가능

///  왜 안될까? 
///    - 기본 타입을 반환하는 함수의 반환값을 수정하는 일은 절대 있을 수 없기 때문! 
///    - 반환 시, '값에 의한 반환'을 수행하는 C++ 의 성질 때문에 오류가 날 가능성 있음.

///  즉, 수정되는 값은 ch[0]의 원본값이 아니라, 사본이기 때문. 
/// </summary>


/// <summary>
///  어떤 멤버 함수가 상수 멤버라는 것은 무슨 의미일까? 
///   1. 비트 수준 상수성  (== 물리적 상수성) 
///     의미 : 어떤 멤버 함수가, 객체의 그 어떤 데이터 멤버도 건드리지 않아야만 상수 멤버 함수로 인정된다. 
///           (객체를 구성하는 비트들 중 어떤 것도 바꾸면 안돼!) 
///     장점 
///      - 상수성 위반 발견 쉬움. (데이터 멤버에 대해 대입 연산이 수행되었는 지만 보면 되기 때문.) 
///      - 상수 멤버 함수에서는 그 함수가 호출된 객체의 어떤 비정적 멤버도 수정할 수 없게 되어있음. 
///	 
///     단점 
///      - const 가 비트 수준 상수성으로 작동하지 않는데도, 비트수준 상수성 검사를 통과하는 멤버함수들의 경우. (어떤 포인터가 가리키는 대상을 수정하는 멤버 함수들) 
///      - 그 포인터가 객체의 멤버로 포함되어 있는 한 위 함수들은 비트 수준 상수성을 가지는 것으로 판별됨. 컴파일러도 문제 없다 여기기 때문에, 
///      - 상상도 못할 동작이 나올 수 있음.
///        예시로, 상수 멤버 함수 오퍼레이터가 참조자를 반환 하는 것. 
///      - 이럴 때, 상수의 역할이 상수의 의미를 지키지 못하는 경우가 생김. 
/// <summary>
/// 즉, 각 객체마다 가진 비트 값이 하나도 변하지 않아야만 상수 멤버 함수로 인정받는 비트 수준 상수성은 컴파일러가 사용하는 방식이며,
///     비트 수준 상수성을 통과하는 상수 포인터 멤버 함수 등을 회피하기 위해 논리적 상수성을 사용해 프로그래밍 하면 좋다.
/// 
///  mutable 키워드는 , 비정적 데이터 멤버를 비트 수준의 상수성의 족쇄에서 풀어준다. 
///  즉, mutable 로 선언한 멤버들은 어떤 순간에도 수정할 수 있다. (멤버 함수 내부에서도!) 
/// </summary>

///   2. 논리적 상수성 
///      의미 : 비트 수준 상수성의 보완하는 대체 개념. 상수 멤버 함수가 객체의 한 비트도 수정할 수 없는 것이 아니라, 일부 몇 비트 정도는 바꿀 수 있되, 그것을 사용자측에서 알아체지 못하게만 한다면 상수 멤버로 인정. 
/// </summary>

void ConstSTLRepetition()
{
	vector<int> vec = { 1, 2, 3, 4, 5 };
	// 벡터 생성 

	for (vector<int>::iterator it = vec.begin(); it != vec.end(); ++it)
	{
		*it += 10;
		// 반복자 사용 .
		// 값이 변경 가능 

	}
	for (vector<int>::const_iterator it = vec.begin(); it != vec.end(); ++it)
	{
		cout << *it << endl;
		// *it += 5; 
		// 읽기만 가능 
		// it 이 가리키는 값을 변경할 수 없다. 
	}

	for (auto it = vec.cbegin(); it != vec.cend(); ++it)
	{
		// cbegin(), cend() -> const_itarator변환형 
		cout << *it << sizeof(*it) << endl;
		// auto 키워드 사용 
		// 반복자 타입을 자동으로 추론 
		// 8비트 크기
		// *it += 10; // 컴파일 오류 발생
	}
}

/// <summary>
/// 상수 멤버 및 비상수 멤버함수에서 코드 중복 현상을 피하자! 
///   여러 코드를 상수 / 비상수 멤버에 각각 넣게 되면, 똑같은 코드들이 중복 선언이 되면서 속도 및 성능이 저하되는 원인이 될 수 있음. 

///  1. 핵심 기능을 한번만 구현해두고 이것을 여러번 사용하는 방법 (const 키워드가 붙어있는 지에 대한 여부에 따른 차이도 주의) 
///    - 캐스팅을 통해서 반환 타입에서 const를 없애자. 
///     - 이 방법이 왜 안전한가? 
///       - 비상수 멤버 함수를 호출하는 쪽에선느 그 호출부에는 비상수 객체가 우선적으로 들어있을 게 분명하기 때문. 
///		  - 안정성도 유지하면서 코드 중복을 피하는 방법으로, 비상수 멤버 함수가 상수 버전 멤버 함수를 호출하도록 구현하기! 
///    
/// 즉, 자유로운 변환이 가능한 찰흙 안에 공을 넣었다 하면, 찰흙이 아무리 모양을 바꾸더라도, 안에 있는 공은 모양이 바뀌지 않는 것. 
///    과 같이, 상수로 선언되지 않은 멤버 함수 안에서는, 상수로 선언된 멤버 함수를 얼마든지 호출할 수 있기 때문에, 
///    이 방법을 사용하면 같은 코드를 굳이 선언 할 필요가 없다.   
/// </summary>

class operatorConst {
private:
	char* pOpc;

	const char& operator[] (size_t pos) const
	{
		return pOpc[pos];
	}
	char& operator[] (size_t pos) // 상수 멤버 쌍둥이 기법 
	{
		return
			const_cast<char&>( //상수 operator[]의  반환 타입에서 const 제거 하는 방법은 const_cast 밖에 없음
				static_cast<const operatorConst&>
				(*this)[pos] // this 타입에 const 붙이기 
			// 안전한 타입 변환 을 강제로 진행하는 것이기 때문에, static cast 만으로도 가능. 
				);

		/// <summary>
		/// cast 가 두번이나 들어간 이유. 
		///   1. 호출하는 operator[]의 무한 재귀호출를 피하기 위해, 상수 operator의 사용이 목적이라는 사실을 명시 하기 위해. 
		///   2. 직접적인 방법은 없기 때문에, this 포인터이 타입에 캐스팅 으로 비상수에서 상수로 변환. (즉, this* 의 타입에 const 를 추가)  
		/// 
		/// 즉, cast 를 사용한 이유는 const 를 붙여서 비상수 멤버 함수에서 호출하기 위함! 
		/// 
		/// 이로서 코드 중복을 회피! 
		/// 
		/// </summary>
	}
};

/// <summary>
///  상수 멤버 함수가  비상수 멤버 함수를 호출하게 만드는 방법은 어떨까? 
///    - 상수 멤버 함수는 해당 객체의 상태를 변경하지 않겠다고 컴파일러와 굳게 약속한 함수인 반면, 
///      비상수 멤버 함수는 아니다. 
///  
/// 즉, 상수 멤버 함수에서 비상수 멤버 함수를 호출 시, 수정하지 않겠다는 약속을 배신한 것과 다름없음. 
/// 
///   왜냐, *this 에 붙은 const 를 떼어내기 위한 const_cast 적용을 하는 것이, 
///        안정성에는 문제 없지만, (비상수 멤버 함수 안에서는 객체를 바꾸든 안바꾸는 자유이기 때문에, 상수 멤버 함수를 호출한다고 해서 특별히 문제는 없다) 
///        그러나, 상수 멤버 함수는 변경되어서는 안돼기 때문에 심각한 오류가 발생할 수도 있다. 
/// 
/// </summary>

// 기억하기 
/// <summary>
///  1. 포인터 / 반복자에 대해서, 그리고 그들이 가리키는 대상에 대해서, 함수의 매개 변수 및 반환 타입에 대해서, 지역변수, 멤버 함수에까지 const는 적용 가능! 
///  2. const로 선언하면 컴파일러가 사용상의 에러를 잡아내는 데 도움이 됨. 
///  3. 어떤 유효범위에 있는 객체에도 붙을 수 있으며, 함수 매개변수 및 반환 타입에도 붙을 수 있고, 멤버 함수 자체에 대해서도 사용 가능. 
///  4. 컴파일러 쪽에서는 비트 수준 상수성을 사용, 사용자 쪽에서는 개념적인(논리적인) 상수성을 사용해 프로그래밍 해야함. 
///  5. 상수 멤버 및 비상수 멤버 함수가 기능적으로 서로 똑같게 구현되어있을 경우, 코드 중복을 피하기 위해서는 , 비상수 버전이 상수 버전을 호출하도록 하는 것이 좋다! 
/// </summary>



/*----------------------------------------------항목 4------------------------------------------------------------------------------------*/

/// <summary>
///  경우에 따라서 변수와 함수와 같은 데이터들을 바로 초기화 하지 않고 사용 시 주의점. 
///   1. 가비지값등의 원하지 않는 값, 또는 정의되지 않은 동작으로 컴파일 에러가 발생 
///   2. 초기화가 언제 되는 지 명확한 때를 c++ 에서는 명확히 기준을 준비 해둠. 
///   3. 그러나, 대입과 초기화의 차이를 명확히 이해하고 사용하세요. 
/// </summary>

// 2번의 예시. 
//  1). 배열은 각 원소가 확실히 초기화 된다는 보장이 없으나, 내부적으로 동적 배열을 사용하는 vector(STL) 에서는 확실히 초기화 된다는 보장을 갖고 있다. 

//-------------------------------- 모든 객체를 사용하기 전에, 항상 초기화 하는 것만이 대비할 수 있는 방법이기도 함!! ----------------------!! 



/// <summary> 클래스에서는 객체의 모든 것을 초기화 하는 것을 잊지말자. 
///  타입 
///   1. 기본 자료형은 언제 초기화될 지 보장되어 있지 않다. 
///   2. 초기화와 대입에 걸리는 비용의 차이가 없지만, 멤버 초기화 리스트에 함께 넣어서 초기화해주는 것이 좋다. 
/// 
///  대입과 초기화 
///   주의. C++ 규칙에서는 어떤 객체이든 그 객체의 데이터 멤버는 생성자의 본문이 실행되기 '전에 초기화되어야 함'.
/// 
///   1. 대입 >  변수 이름 = 값; 
///  - 이미 선언된 변수에 값을 할당하는 것 
///  - 대입 연산자(= )를 사용하여 값을 변경 
///  - 대입은 초기화 이후에 실행. (중요) > 이는 객체의 데이터 멤버는 생성자가 실행되기 전에 초기화 되어야 한다는 명확한 기준을 어김 
///  - 대입은 객체가 생성된 후에 실행되므로, 객체의 상태가 초기화되지 않은 상태에서 대입을 시도하면 가비지 값이 들어갈 수 있다.
///   - 새 데이터 멤버의 기본 생성자를 추가적으로 호출 하는 것. 
///   2. 초기화 
///  - 객체가 생성될 때, 멤버 변수를 초기화하는 것 
///  - 멤버 초기화 리스트를 사용 > 생성자(파라메터) : 변수이름(파라메터)
///  - 멤버 초기화 리스트로 받는 생성자 파라메터를 객체의 데이터에 초기화 하는 것 
/// 
/// 멤버 초기화 리스트에서 반드시 초기화를 시켜야 하는 경우. 
///   1. 상수 
///   2. 참조자 
///  이유는, 상수와 참조자 둘 다 대입 자체가 불가능 하기 때문! 
/// </summary>

/// <summary>
///  즉, 대입하는 데이터 멤버들의 기본 생성자를 호출해 초기화를 미리 한 이후에 생성자에서 곧바로 새로운 값을 대입하는 대입 방식 보다, 		
///      생성자의 인자로 쓰이기 때문에 바로 초기화가 가능한 멤버 초기화 리스트 를 사용하는 것이 더 효율적일 수 있다. 
/// (복사 생성자를 사용하는 방식 보다도 멤버 초기화 리스트가 더 효율적일 수 있다는 이야기.) 
/// 
///  멤버 초기화 리스트로 초기화 되지 않은 멤버나, 사용자 타입의 멤버 등을 컴파일러가 자동으로 멤버들에 대한 기본 생성자들을 호출하게 되어있기 때문에, 
///      어떤 멤버가 초기화되지 않았다는 실수를 방지할 수 있다. -> 모든 멤버를 멤버 초기화리스트에 초기화하는 것이 중요한 이유! 
/// 
/// 말하고 싶은 것: 멤버 초기화 리스트의 사용을 일상화 하는 것이 더 안정성을 높이고, 사용자의 실수를 줄일 수 있다!
///   그러나, 그렇다고 대입을 통한 초기화가 아예 필요없는 것은 아니다. 
///		 멤버와 기본 클래스가 많이 붙어있다면 대입으로도 초기화가 가능한 멤버들을 함수로 분리해 생성자에서 호출하는 것이 좋을 수도 있다. 
///		 (멤버의 진짜 초기값을 파일에서 읽어온다든지, 데이터 베이스에서 찾아오는 경우에 특히 유용!) 
/// </summary>

// <--------------------------------------------------------------------객체 멤버 데이터의 초기화 순서. 
/// <summary>
/// 
/// 1. 부모 클래스가 파생된 클래스 보다 초기화 순서가 우선시 됨. 
/// 2. 클래스 데이터 멤버는 그들이 선언된 순서대로 초기화 (멤버 변수의 선언 순서) 
/// 3. 멤버 초기화 리스트의 초기화 순서과 관계없이, 선언 순서가 기준. (동작 버그를 피하기 위해선 멤버 초기화 리스트의 초기화 순서를 선언 순서와 맞추는 것이 좋음) 
/// 
/// 주의. 비지역 정적 객체의 초기화 순서는 개별 번역 단위에서 정해진다!!
///   (번역 단위 란, 컴파일로 하나의 목적 파일을 만드는 바탕이 되는 소스 코드와 include 하는 파일들까지 포함해 말한다. 즉, 헤더 파일과 cpp 파일. 번역이란, 소스의 언어를 기계어로 옮기는 것) 
/// 
/// </summary>

// <정적 객체의 비지역 / 지역 구분> 
/// <summary>
/// 정적 객체의 범주 내에 있는 요소들 
///  1. 전역 객체
///  2. 네임 스페이스 유효범위 안으로 선언된 객체 
///  3. 클래스 안에서 static 으로 선언된 객체 
///  4. 파일 유효 범위 안에서 static 으로 선언된 객체  
/// 1 ~ 4번 까지의 요소들은 비지역 정적 객체이다. 
///  - 비지역 정적 객체는 함수 호출 중, 함수 안의 객체의 정의에 최초로 닿았을 때 초기화되도록 되어있음. 
/// 
///  5. 함수 안에서 static 으로 선언된 객체 (지역 정적 객체) 
/// 
/// 위 다섯가지의 요소들은 프로그램이 끝날 때까지 살아있는 객체들이며, 프로그램이 끝날 때 소멸한다. 즉, main() 함수의 실행이 시작될 때와 끝날 때를 말한다.) 
/// </summary>


class ClassInit {
private:
	int a;
	int b;
	int& refvalue; // 참조 변수 
	const int cvalue;
	// 테스트를 위해서 선언 직후 초기화 하지 않음. 원래는 선언 직후  바로 해야함
	// 초기화 해야 할 멤버 변수 들 (객체가 가지는 데이터들) 
	static const int av = 10;
	// static int av =10 ; 는 제대로 작동하지 않는다. 
	//inlin static int av = 10; == static int av = 10; // 단, inline 사용시 전방 선언은 불가! 
	// static 멤버는 클래스 내에서 선언만 하고, cpp 파일에서 정의해야 한다. 
	// static 멤버로 선언되는 함수 또는 변수는 클래스와 관계없이 전역처럼 사용이 가능하기 때문에, 
	// 여러 파일에서 include 가 가능하기 때문이다.


public:
	// 멤버 초기화 리스트 생성자 
	ClassInit(int a, int b, int& ref, int constvalue) : a(a), b(b), refvalue(ref), cvalue(constvalue) // 멤버 초기화 리스트를 사용하여 초기화 
	{
		// 생성자 본문 
		// 멤버 변수 초기화 
		// cvalue 는 const 이므로, 초기화 리스트에서만 초기화 가능 
		// 멤버 초기화 리스트로 받는 파라메터의 값을 복사해 객체의 데이터 멤버에 초기화하는 복사 생성자. 
		// 초기화 순서는 멤버로 선언 한 순서가 기준이 된다. 
	}
	static int GetA() { return av; }
	//static int SetA() const; 
	// 정적 멤버 함수 예시. 객체가 아닌 클래스 자체에 속하는 함수.
	// this 포인터가 없기 때문에, 객체의 일반 데이터 멤버에는 접근 할수 없음. 또한 const 역시 사용 불가. 
	int Getvalue() { return av; }
	static const int SetcValue() { return av; }
	// 정적으로 선언되기는 했으나, const 가 선언된 것은 리턴값을 명시하는 int 에 관한 상수 멤버로 선언되었기 떄문에 사용이 가능하다. 

	// 비지역 정적 멤버와 정적 멤버의 불명확한 초기화 순서로 인한 혼란을 막기 위해, 
	// 비지역 정적 멤버 함수를 각 객체마다 정의해 호출하는 것이 좋다. 즉, 비지역 정적 객체를 정적 객체로 변경! 
	// 예시> 


	ClassInit(const ClassInit& other)
		: a(other.a), b(other.b), refvalue(other.refvalue), cvalue(other.cvalue) // 복사 생성자 
	{
		// 복사 생성자 본문 
		// 객체의 데이터 멤버를 다른 객체의 데이터 멤버로 초기화 
		// 컴파일러에서 자동으로 생성하는 복사 생성자와 동일한 동작을 한다. 
	}

	// 만약 class 내에 아무 생성자도 없을 시 컴파일러가 자동으로 생성하는 기본 생성자 
	//ClassInit() 
	//{
	//	a = 10; 
	//	b = 20; 
	//	iptr = nullptr; 
	//	cvalue = 100; // const 변수는 생성자에서 초기화 해야함. 
	//}
	void debug_print(const char* objName) const {
		std::cout << "---- [" << objName << "] Debug Info ----\n";
		// 1) this 포인터 (객체 전체의 시작 주소)
		std::cout << " this(객체 전체의 시작 주소) = " << static_cast<const void*>(this) << "\n";

		// 2) 멤버 'a'의 값 및 주소
		std::cout << " &" << objName << ".a       = "
			<< static_cast<const void*>(&a)
			<< "  (value: " << a << ")\n";

		// 3) 멤버 'b'의 값 및 주소
		std::cout << " &" << objName << ".b       = "
			<< static_cast<const void*>(&b)
			<< "  (value: " << b << ")\n";

		// 4) 참조 멤버 'refubt'의 주소(참조 멤버 자체가 가진 주소)와 
		//    refubt가 가리키는 대상(int 변수)의 주소, 값
		std::cout << " &" << objName << ".refubt  = "
			<< static_cast<const void*>(&refvalue)
			<< "  (refers to address: " << static_cast<const void*>(&refvalue)
			<< ", referent value: " << refvalue << ")\n";
		// 참고: 참조 멤버 자체는 내부적으로 참조 대상의 메모리 주소를 붙들고 있으므로,
		//       '&refubt'와 'refubt'가 같게 보이지만, 이 코드는 “참조 자체의 주소”를 찍기 위함.
		//       많은 컴파일러에서 참조 자체는 별도 메모리를 갖지 않고, referent 주소를 곧바로 가리키지만,
		//       표준 차원에서는 “&refubt”가 “referent의 주소”와 동일한 것으로 간주할 수 있습니다.

		// 5) const 멤버 'cvalue'의 주소와 값
		std::cout << " &" << objName << ".cvalue = "
			<< static_cast<const void*>(&cvalue)
			<< "  (value: " << cvalue << ")\n";

		std::cout << "---------------------------------------------\n\n";
	}
};

void ClassInitializeTest() {
	std::cout << "\n====== 1) 멤버 초기화 리스트 생성자 테스트 ======\n\n";

	int externalInt = 100;
	// ClassInit(int a, int b, int& ref, int constvalue);
	ClassInit original(10, 20, externalInt, 500);

	// object의 멤버들이 어떻게 초기화되었는지, 주소·값을 출력
	original.debug_print("original");

	// 외부 변수 'externalInt'를 바꾸면 refubt가 가리키는 값이 함께 바뀌는지 확인
	std::cout << "--> externalInt 값을 777로 변경\n";
	externalInt = 777;
	std::cout << " externalInt = " << externalInt << "\n";
	std::cout << " original.refubt (referent) = " << externalInt << "\n\n";

	original.debug_print("original_after_external_change");


	std::cout << "\n====== 2) 복사 생성자 테스트 ======\n\n";

	// obj1을 복사하여 obj2 생성. 복사 생성자 호출
	ClassInit clone = original;

	// 복사된 obj2가 obj1과 어떤 값·주소를 공유하는지 확인
	clone.debug_print("clone");

	// obj2의 참조 멤버(refubt)가 same externalInt를 가리키는지 확인
	std::cout << "--> 복사된 clone.refubt 의 referent 값을 888로 변경\n";
	// obj2.refubt = 888; // 이 코드는 컴파일 오류: refubt가 'int& const'처럼 상수참조이므로 재할당 불가
	externalInt = 888;
	std::cout << " externalInt = " << externalInt << "\n";
	std::cout << " original.refubt = " << /* original.refubt */ externalInt
		<< ", clone.refubt = " << /* clone.refubt */ externalInt << "\n\n";

	original.debug_print("original_after_copy");
	clone.debug_print("clone_after_copy");

}

// 초기화 순서가 정해져 있지 않은 비지역 정적 객체들의 초기화는 직접 하지 않는 것이 좋다. 
#include "ChapterOne_s.h" 
#include "StaticTest.h"
class dir : public StaticTest // StaticTest 부터 초기화된다. 
{
public:
	int n;
	dir(int a) : n(a)
	{
		// 생성자 본문 
		// cClass 객체를 초기화 
		// 비지역 정적 객체를 정적 객체로 변경하여, 초기화 순서가 명확히 정해지도록 한다. 
		//int friendclass = CClass().Getvalue(); // 정적 멤버 함수 호출 
		// 이 방식을 사용하려면 다른 파일에서 extern 으로 선언해야함. 

	}
	dir& dirs() {
		static dir;
		// 정적 멤버 객체로 만들어서 프로그램 종료 시 소멸 하게 함. 
		// 다른 소스 파일에 있는 비정적 객체와의 초기화 순서가 정해져 있지 않기 때문에, 
		// 비정적 객체의 초기화가 진행될 시, 다른 소스파일에 있는 비정적 객체가 사용이 됨. 
		return *this; // 정적 멤버 함수로 선언하여, 객체가 하나만 존재하게 한다.; 
	}
};

class TempDir {
	class dir;
public:
	TempDir& tempDir()
	{
		static TempDir td;
		return td; // 정적 멤버 함수로 선언하여, 객체가 하나만 존재하게 한다.; 

	}

	void temps(int id)
	{
		//int d = dir().n; //사용 
	}

};


//  만약, 두개의 소스 파일 중에, 한쪽이라도 비지역 정적 객체가 한개 이상 있는 경우 초기화 순서는 어떻게 되는가? 
/// <summary>
///  
///  한쪽 소스파일에서 비정적 객체의 초기화가 진행 하면서, 비정적 객체 안에서 다른 쪽 소스 파일에 있는 비지역 정적 객체를 사용할 경우, 비지역 정적 객체의 초기화가 되어있지 않을 수도 있다! 
/// 
///       Person(int n) :num(n) 
///			{
///			    HP = tfs.hp;	
///			} // tfs.hp 은 외부 소스파일에서 선언된 객체의 멤버를 가져온 경우. 
///     이럴 때, StaticNum 이 초기화 되어있지 않을 가능성 있음! 
/// 
///  이유는, 서로 다른 소스 파일에서 정의된 비지역 정적 객체들 사이의 상대적인 초기화 순서는 정해져 있지 않다는 것. 
/// 
/// 이를 방지 하기 위해선, 비지역 정적 객체를 하나씩 맡는 함수를 준비하고, 안에 각 객체를 넣는 것.  
///  즉, 객체들의 참조자를 반환하는 정적 객체 함수를 선언하면 대비할 수 있다! 
/// 
/// 비지역 정적 객체를 지역 정적 객체로 변경! 
///   객체의 참조자를 반환하는 함수를 대신해서 호출하여서, 반드시 초기화된 객체를 참조하도록 한다.  (지역 객체 참조자 반환 함수를 호출할 일이 없다면 해당 객체의 생성 / 소멸 비용도 생기지 않게 막아야 한다. 
/// 
/// 즉, 객체가 아닌, 함수로 선언해 내부 객체를 사용할 수 있게 함으로서 정적 객체 자체를 사용하지 않고, 그 객체에 대한 참조자를 반환하는 함수를 사용하게 함으로서 정해져 있지 않은 초기화 순서에 대한 문제를 대비할 수 있다. 
///     단, 객체들의 초기화 순서를 제대로 맞춰둬야하는 것이 전제가 되어있어야 한다. 
/// 
/// </summary>

/// <summary>
///  1. 기본 자료형 타입 객체는 직접 초기화. 경우에 따라 자동으로 되기도 하지만 큰 기대는 no! 
///  2. 생성자에서는, 대입 연산자를 사용한 초기화 보다, 멤버 초기화 리스트의 사용을 일상화 하고, 리스트에 나열할 때에는 각 멤버가 선언된 순서와 똑같이 나열하자! 
///  3. 여러 번역 단위에 있는 비지역 정적 객체들의 초기화 순서 문제는 피해서 걸계할 것. -> 비지역 정적 객체를 지역 정적 객체로 변환해 사용할 것. 
/// </summary>


class Player {
private:
	int _health;
	int _power;
	const string _name;
	// 상수 멤버는 멤버 초기화 리스트에서만 초기화 가능 
	// 또는, const string _name = "default name"; 과 같은 in-line 초기화 가능 
public:
	//// 생성자 뿐만 아니라 클래스 내의 모든 멤버 함수는 오버로딩이 가능하다. 
	Player(int hp, int power)
	{
		_health = hp;
		_power = power;
		//_name = "const name initialize don't do it"; // _name 은 const 이므로, 생성자의 대입 연산자로는 초기화되지 않음! 
		// 대입 연산자는 어디까지나 값을 할당 해주는 것이고, 반드시 대입 이전에 초기화가 이루어져야만 한다. 
		// 초기화 순서 및 초기화 시점이 명확히 정해져 있기 때문. 

		cout << "오버로딩된 생성자 health : " << _health << ", power : " << _power << endl;
	}
	//Player() // 디폴트 생성자. -> 생성자가 전혀 선언되어있지 않을 시 컴파일러가 자동으로 생성 
	//{
	//	_health = 100; // 기본값으로 초기화 
	//	_power = 10; // 기본값으로 초기화  
	//	cout << "디폴트 생성자 health : " << _health << ", power : " << _power << endl; 
	//}
	Player(const Player& other) // 복사 생성자 
		: _health(other._health), _power(other._power)// 멤버 초기화 리스트를 사용하여 초기화 
	{ // 초기화 순서는 선언된 멤버 순서가 기준이 된다. 
		cout << "복사 생성자 health : " << _health << ", power : " << _power << endl;
	}

};

void classInitTest()
{
	//Player p1; 
	Player p2(200, 20); // 오버로딩된 생성자 호출 (파라메터를 가진 생성자를 오버로딩)  
	Player p3 = p2;		// 복사 생성자 호출 

}


int main()
{
	cout << "항목 2. 매크로 상수 : " << SIZE << endl;
	cout << "----------------------------------매크로 상수보다 const 를 사용해보세요." << endl;
	cClassTest(); // cClass 테스트 
	cout << endl;

	cout << "---------------------------------------------------------inline 함수" << endl;
	int a = 10;
	int b = 20;

	float x = 1.3f;
	float y = 4.2f;

	Game g;
	cout << "----------------------------------정수 타입" << endl;
	g.CallWidthMin(a, b);
	cout << "----------------------------------실수 타입" << endl;
	g.CallWidthMin(x, y);

	ClassInitializeTest();
	cout << endl;
	//callWithMax(3, 5); // 템플릿 함수 호출 예시
	//int j = callWithMax(3, 5);
	//cout <<  << endl; // 템플릿 함수 호출 예시
	classInitTest();


}
